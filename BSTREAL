#lang racket

(struct node (value count left right) #:mutable #:transparent)

(define n10 (node 70 1 null null)) 
(define n09 (node 65 1 null n10)) 
(define n08 (node 30 1 null null)) 
(define n07 (node 87 1 null null)) 
(define n06 (node 60 1 null n09)) 
(define n05 (node 37 1 n08 null)) 
(define n04 (node 57 1 null null)) 
(define n03 (node 75 1 n06 n07)) 
(define n02 (node 25 1 n04 n05)) 
(define n01 (node 50 1 n02 n03)) 

;excercise 1
(define (bst? n)
  (cond
    
    ((empty? n) #t) ;check if its empty

    ((not (node? n)) #f) ;checks if a node struct

    ((and (empty? (node-left n)) ;checks to make sure node has no children
          (empty? (node-right n)) ) #t) ;if no children it's returns true

     ((and (empty? (node-right n)) ;checks no right node
           (and (bst? (node-left n) )
           (< (node-value (node-left n) )
              (node-value n)) )
         
           ) #t)

     ((and (empty? (node-left n))
           (and (bst? (node-right n) )
           (> (node-value (node-right n ) )
              (node-value n)) )
           ) #t)

     
     ((and (and (bst? (node-left n) )
           (< (node-value (node-left n) )
              (node-value n)) )
           
           (and (bst? (node-right n) )
           (> (node-value (node-right n ) )
              (node-value n)) )
           ) #t

           

     ;and check-L < current-N
     ;and bst? check-L 

     )))



(define (find-path n v) 
  (cond

    ((empty? n) '() ) ;checks if n is empty return empty list

    ( (= v (node-value n)) ; if n.value is v 
           (list n))  ; result is list containing n

    ((and (< v (node-value n) ) ;checks if v is less than current node
             (empty? (node-left n) ) ) ;checks if left node is empty

               (list n)) ;return list contaning n

    ( (and (< v (node-value n ) ) ;checks i v is less than node-value n
          (not (empty? (node-left n) )))  ;checks to make sure node-left is not empty

           (append (list n)  (find-path (node-left n)  v) ) ;appends and recursively calls
               )

    ( (> v (node-value n)) ; checks v greater than current node value
          (and (empty? (node-right n) ) ) ;checks right node is empty
          (list n)) ;return list

    ( (> v (node-value n))
          ((not (empty? (node-right n) ) )
           (append (list n) (find-path (node-right n) ) 
           )))
))  
(find-path n01 5)

(define (node-list-to-value-list x)
  (cond
    ((empty? x ) '() )
    
  (cons (node-value (car x) ) (node-list-to-value-list (cdr x)))
  
    ) )


;excercise 2

(define (traverse n)
  (cond
    ((empty? n) '() )

    (else (append ( traverse (node-value (node-left n) ) )
                  ((list n)
                  (traverse (node-value (node-right n) ) )
                  ))))
  )

(define (inorder? x)
  (cond
    ((empty? (cdr x)) #t )
    
  ((and (< (node-value (car x)) ;grabs first element
        (node-value (cadr x) ) ) ;grabs second element
        
       (inorder? (cdr x))) ;grabs all elements starting from the second element
  )  
))

(define (insert n v)
  (let ((stack(find-path n v)))
    (cond
      
      ((empty? stack) ;checks for empty stack
       (node v 1 null null) ;creates new node
       n ))

       (((= (v (node-value (car stack) ) ;checks if v is equal to value of head of stack
            (+ (node-count (car stack))) ) ;increments count of v           
              )))) )
               
